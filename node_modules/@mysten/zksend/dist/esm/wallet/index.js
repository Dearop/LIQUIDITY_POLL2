var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};
var _events, _accounts, _origin, _name, _signTransactionBlock, _signPersonalMessage, _on, _setAccount, setAccount_fn, _connect, _disconnect;
import { bcs } from "@mysten/sui.js/bcs";
import { toB64 } from "@mysten/sui.js/utils";
import { getWallets, ReadonlyWalletAccount, SUI_MAINNET_CHAIN } from "@mysten/wallet-standard";
import mitt from "mitt";
import { DEFAULT_STASHED_ORIGIN, StashedPopup } from "./channel/index.js";
const STASHED_RECENT_ADDRESS_KEY = "stashed:recentAddress";
const STASHED_WALLET_NAME = "Stashed";
class StashedWallet {
  constructor({
    name,
    address,
    origin = DEFAULT_STASHED_ORIGIN
  }) {
    __privateAdd(this, _setAccount);
    __privateAdd(this, _events, void 0);
    __privateAdd(this, _accounts, void 0);
    __privateAdd(this, _origin, void 0);
    __privateAdd(this, _name, void 0);
    __privateAdd(this, _signTransactionBlock, async ({ transactionBlock, account }) => {
      transactionBlock.setSenderIfNotSet(account.address);
      const data = transactionBlock.serialize();
      const popup = new StashedPopup({ name: __privateGet(this, _name), origin: __privateGet(this, _origin) });
      const response = await popup.createRequest({
        type: "sign-transaction-block",
        data,
        address: account.address
      });
      return {
        transactionBlockBytes: response.bytes,
        signature: response.signature
      };
    });
    __privateAdd(this, _signPersonalMessage, async ({ message, account }) => {
      const bytes = toB64(bcs.vector(bcs.u8()).serialize(message).toBytes());
      const popup = new StashedPopup({ name: __privateGet(this, _name), origin: __privateGet(this, _origin) });
      const response = await popup.createRequest({
        type: "sign-personal-message",
        bytes,
        address: account.address
      });
      return {
        bytes,
        signature: response.signature
      };
    });
    __privateAdd(this, _on, (event, listener) => {
      __privateGet(this, _events).on(event, listener);
      return () => __privateGet(this, _events).off(event, listener);
    });
    __privateAdd(this, _connect, async (input) => {
      if (input?.silent) {
        const address = localStorage.getItem(STASHED_RECENT_ADDRESS_KEY);
        if (address) {
          __privateMethod(this, _setAccount, setAccount_fn).call(this, address);
        }
        return { accounts: this.accounts };
      }
      const popup = new StashedPopup({ name: __privateGet(this, _name), origin: __privateGet(this, _origin) });
      const response = await popup.createRequest({
        type: "connect"
      });
      if (!("address" in response)) {
        throw new Error("Unexpected response");
      }
      __privateMethod(this, _setAccount, setAccount_fn).call(this, response.address);
      return { accounts: this.accounts };
    });
    __privateAdd(this, _disconnect, async () => {
      localStorage.removeItem(STASHED_RECENT_ADDRESS_KEY);
      __privateMethod(this, _setAccount, setAccount_fn).call(this);
    });
    __privateSet(this, _accounts, []);
    __privateSet(this, _events, mitt());
    __privateSet(this, _origin, origin);
    __privateSet(this, _name, name);
    if (address) {
      __privateMethod(this, _setAccount, setAccount_fn).call(this, address);
    }
  }
  get name() {
    return STASHED_WALLET_NAME;
  }
  get icon() {
    return "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTYiIGhlaWdodD0iNTYiIHZpZXdCb3g9IjAgMCA1NiA1NiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3QgeD0iMSIgeT0iMSIgd2lkdGg9IjU0IiBoZWlnaHQ9IjU0IiByeD0iMjciIHN0cm9rZT0iYmxhY2siIHN0cm9rZS13aWR0aD0iMiIvPgo8cGF0aCBkPSJNMTguMzUyOCAzNS4wNjM4QzE5LjI3NDIgMzguNTAyNSAyMi43MTU3IDQxLjYxNTQgMjkuODM2MSAzOS43MDc1QzM2LjYzMDEgMzcuODg3IDQwLjg4OCAzMi4yOTggMzkuNzgzOSAyOC4xNzc2QzM5LjQwMjYgMjYuNzU0NyAzOC4yNTQyIDI1Ljc5MTUgMzYuNDgzNyAyNS45NDgyTDIwLjY1MTkgMjcuMjY3M0MxOS42NTQ4IDI3LjM0MzggMTkuMTk3NiAyNy4xODA0IDE4LjkzMzkgMjYuNTUyMUMxOC42NzgxIDI1Ljk1MzQgMTguODIzOCAyNS4zMTA3IDIwLjAyODEgMjQuNzAyTDMyLjA3NjQgMTguNTE4OUMzMi45OTk4IDE4LjA0OTEgMzMuNjE0OSAxNy44NTI1IDM0LjE3NyAxOC4wNTE0QzM0LjUyOTIgMTguMTc5NCAzNC43NjEyIDE4LjY4OTEgMzQuNTQ4MiAxOS4zMTgxTDMzLjc2NyAyMS42MjQ0QzMyLjgwODMgMjQuNDU0OCAzNC44NjA2IDI1LjExMjIgMzYuMDE3NiAyNC44MDIyQzM3Ljc2ODEgMjQuMzMzMiAzOC4xNzk5IDIyLjY2NiAzNy42MTU5IDIwLjU2MTNDMzYuMTg2MiAxNS4yMjU0IDMwLjUyNTIgMTQuMzkxMiAyNS4zOTI2IDE1Ljc2NjRDMjAuMTcxIDE3LjE2NTYgMTUuNjQ0NiAyMS4zOTY3IDE3LjAyNjcgMjYuNTU0N0MxNy4zNTI0IDI3Ljc3MDEgMTguNDcxMSAyOC43NDEyIDE5Ljc2NyAyOC43MTE3TDIxLjc0NTIgMjguNzA2OUMyMi4xNTIxIDI4LjY5NzUgMjIuMDA1NiAyOC43MzA5IDIyLjc5MDUgMjguNjY1OUMyMy41NzUzIDI4LjYwMDkgMjUuNjcxNSAyOC4zNDMgMjUuNjcxNSAyOC4zNDNMMzUuOTU3MiAyNy4xNzlMMzYuMjIyMiAyNy4xNDA1QzM2LjgyMzcgMjcuMDM3OSAzNy4yNzgzIDI3LjE5NDIgMzcuNjYyNyAyNy44NTYzQzM4LjIzNzkgMjguODQ3MSAzNy4zNjAzIDI5LjU5NDMgMzYuMzA5OCAzMC40ODg4QzM2LjI4MTcgMzAuNTEyNyAzNi4yNTM1IDMwLjUzNjcgMzYuMjI1MSAzMC41NjA5TDI3LjE4MzcgMzguMzUzQzI1LjYzMzkgMzkuNjg5NiAyNC41NDUzIDM5LjE4NyAyNC4xNjQgMzcuNzY0MUwyMi44MTM3IDMyLjcyNDdDMjIuNDgwMSAzMS40Nzk3IDIxLjI2NDQgMzAuNTAyOCAxOS44NDAzIDMwLjg4NDRDMTguMDYwMiAzMS4zNjEzIDE3LjkxNTkgMzMuNDMzNCAxOC4zNTI4IDM1LjA2MzhaIiBmaWxsPSJibGFjayIvPgo8L3N2Zz4K";
  }
  get version() {
    return "1.0.0";
  }
  get chains() {
    return [SUI_MAINNET_CHAIN];
  }
  get accounts() {
    return __privateGet(this, _accounts);
  }
  get features() {
    return {
      "standard:connect": {
        version: "1.0.0",
        connect: __privateGet(this, _connect)
      },
      "standard:disconnect": {
        version: "1.0.0",
        disconnect: __privateGet(this, _disconnect)
      },
      "standard:events": {
        version: "1.0.0",
        on: __privateGet(this, _on)
      },
      "sui:signTransactionBlock": {
        version: "1.0.0",
        signTransactionBlock: __privateGet(this, _signTransactionBlock)
      },
      "sui:signPersonalMessage": {
        version: "1.0.0",
        signPersonalMessage: __privateGet(this, _signPersonalMessage)
      }
    };
  }
}
_events = new WeakMap();
_accounts = new WeakMap();
_origin = new WeakMap();
_name = new WeakMap();
_signTransactionBlock = new WeakMap();
_signPersonalMessage = new WeakMap();
_on = new WeakMap();
_setAccount = new WeakSet();
setAccount_fn = function(address) {
  if (address) {
    __privateSet(this, _accounts, [
      new ReadonlyWalletAccount({
        address,
        chains: [SUI_MAINNET_CHAIN],
        features: ["sui:signTransactionBlock", "sui:signPersonalMessage"],
        // NOTE: Stashed doesn't support getting public keys, and zkLogin accounts don't have meaningful public keys anyway
        publicKey: new Uint8Array()
      })
    ]);
    localStorage.setItem(STASHED_RECENT_ADDRESS_KEY, address);
  } else {
    __privateSet(this, _accounts, []);
  }
  __privateGet(this, _events).emit("change", { accounts: this.accounts });
};
_connect = new WeakMap();
_disconnect = new WeakMap();
function registerStashedWallet(name, {
  origin
}) {
  const wallets = getWallets();
  let addressFromRedirect = null;
  try {
    const params = new URLSearchParams(window.location.search);
    addressFromRedirect = params.get("stashed_address") || params.get("zksend_address");
  } catch {
  }
  const wallet = new StashedWallet({
    name,
    origin,
    address: addressFromRedirect
  });
  const unregister = wallets.register(wallet);
  return {
    wallet,
    unregister,
    addressFromRedirect
  };
}
export {
  STASHED_WALLET_NAME,
  StashedWallet,
  registerStashedWallet
};
//# sourceMappingURL=index.js.map
